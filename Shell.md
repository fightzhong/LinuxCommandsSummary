### Vim(配置文件单独放置, 以后会不断的补全, git中打开raw后直接wget下载到Linux就好了)
  - vim环境和shell环境: 执行:sh命令切换到shell环境, 执行exit命令回到vim环境
  - 向下/上滚动一页: Ctrl + f / Ctrl + b
  - 复制/黏贴/删除: ndd删除n行, nyy复制n行, p在当前鼠标下一行黏贴, 不加n则表示删除/复制当前行
  - 块的操作: 普通模式下按v进入可视化模式, 通过移动光标来选中一段文字, y复制, d剪贴
  - 缩进: 编辑模式下tab键和删除键可以用来控制缩进, 非编辑模式下 <<, >>代表向左/右缩进3
  - 清空光标前面内容(命令行/vim中): Ctrl + u
  - 替换文本命令: [ n1,n2s/旧字符串/新字符串/g ] 如果要替换全部则 [1,$s/旧字符串/新字符串/g]
  - 关闭Linux中beep声音
    ```
    vim /etc/inputrc => 取消set bell-style none的注释
    ```

### 变量(变量的数据类型都是字符串)
  - set: 查看所有变量(包括用户定义的, 环境变量)
  - unset 变量名: 删除该变量(包括用户定义的, 环境变量)
  - $变量名: 获取变量的值
  - "$变量a"值: 将变量a的值和后面的值叠加起来
#### 用户自定义变量: 由用户自定义的变量
  - 定义: 变量名=变量值(等号两边不能有空格)
  - 生命周期: 用户自定义变量仅仅在当前的bash环境下生效, 一旦关闭了当前这个bash就失效(比如两个root终端, 一个设置了用户自定义变量, 另一个是不能看到的)
#### 环境变量
  - 定义: export 变量名=变量值 或者 export 变量名(将用户自定义变量设置为环境变量)
  - 生命周期: 当前bash环境和其子孙bash环境都能访问
  - $LANG: 当前系统的语言环境
#### 位置参数变量
  - $n: 代表执行该脚本的时候传入的参数, 1-9依次代表第1-9个参数, 如果大于9则要用大括号括起来, ${10}代表第10个参数
  - $*: 代表整个参数列表, 将整个参数列表看作一个整体
  - $@: 代表整个参数列表, 将整个参数列表分开看待, 类似于每一个参数放入了一个数组
  - $#: 返回参数的个数
#### 预定义变量
  - $?: 保存的是上一个命令的状态, 如果为0则命令正常执行, 非0则命令非正常执行
  - $$: 保存的是当前正在执行的进程的PID
  - $!: 查看后台中最后一个运行的程序
#### read: 读取用户输入的值并存入变量
  ```
  read -p "提示信息" [-n 字符数] [-t xxx] 变量名
  -p用于指定提示信息
  -n表示最多输入的字符个数
  -t表示在指定秒内没输入就会停止read命令
  -s表示隐藏用户的输入
  ```
### declare命令声明变量
  - declare -/+[选项] 变量名
    ```
    普通方式声明变量: 变量名=变量值
    declare命令声明变量:
      -/+: 减代表赋予变量的属性, 加代表取消变量的属性  
      -i: 声明一个整型, 后面可以进行数值运算, 正常的变量声明时数值运算符会被当成字符串处理
      -x: 声明为环境变量, 命令(export 变量名)实际上执行的就是(declare -x 变量名)
      -a: 声明一个变量为数组(了解即可), 也可以直接声明(数组名[i]=值)
      -p: 查看变量的类型
        declare -p aaa: 查看变量aaa的类型
        declare -p: 查看所有变量的类型
    ```  
### 数值运算(以加法为例)
  ```
  方式一: declare -i 变量名=10+10
  方式二(推荐): 变量名=$(($a + $b))
  方式二: 变量名=$(expr $a + $b) 加号两边必须有空格
  ```  
### 文字输出命令
#### echo
  - echo "xxx": 输出字符
  - echo -e "xxx": 可以输出特殊字符, 解析反斜线\
    ```
    echo -e "\e[1;35m 文字内容 \e[0m": 输出文字内容, 并且带有颜色35m
    echo -e "a\tb\tc": 输出abc, 之间存在制表符
    ```   
#### printf: 以标准的格式输出字符(不能读取文字流)
> 该命令类似于echo命令, 不同的是, echo命令会按文字的原来格式输出, 而该命令需要自己指定格式
  - printf '输出类型输出格式' 文字
    ```
    <1> 由于不能读取文字流, 所以该命令不能处理文件, 只能处理文字
    <2> 如果要处理文件, 需要将文件的内容放入一个变量中, 从而读取该变量的内容: printf $(cat student.txt)
    输出类型: %s, %i, %m.nf分别代表字符串, 整型, 浮点型的输出
    输出格式: \t, \n分别代表制表符, 换行符
    注意: 以字符串为例, %s代表一个字符串, 两个字符串以多个制表符或者空格隔开, 就是说区分两个字符串的标志是换行符和制表符(无论多少个)
    例子: printf "%s\t%s\n" a   b         c
    结果: a   b
          c
    分析: %s代表一个字符串, 两个字符串之间用制表符分开, 然后输出完两个字符串后用换行符进行换行, 所以对于a b两个字符串输出完后, 会输出一个换行符,
          然后对后面的字符再运用该规则
    ```       
### 字符截取命令
#### grep: 截取指定的行
  - grep str 文件名: 在文件中截取每一行中有str字符的行
  - grep -v str 文件名: 反向截取, 在文件中截取所有行, 除了行中有字符串str的
    ```
    配合管道符的使用: cat student.txt | grep -v Name 截取student文件中的所有内容, 除了该行中有Name字符串的
    ```  
#### cut: 截取指定的列(规则的文字流才能正确的进行截取)
  - cut -f n1,n2.. 文件名: 截取文件第n1,n2...列的值
  - cut -f n1,n2.. -d "文件分割的标志" 文件名: 自定义文件分隔符(默认为制表符)
  ```
  例子: 截取/etc/passwd文件下的用户名
      cat /etc/passwd | grep /bin/bash | grep -v root | cut -f 1 -d ":"
  弊端: 默认的分隔符为制表符, 那么对于文件中每一列都是以空格隔开, 并且空格是多个的, 这样就算用空格作为分隔符, 那也很难确定列数了    
  ```
#### 通过cut, printf, grep命令操作不规则文字流:
  ```
  不规则文字流(空格数量不一致): df -h
    Filesystem      Size  Used Avail Use% Mounted on
    /dev/sda2        17G  1.2G   15G   8% /
    devtmpfs        476M     0  476M   0% /dev
    tmpfs           487M     0  487M   0% /dev/shm
    tmpfs           487M  7.6M  479M   2% /run
    tmpfs           487M     0  487M   0% /sys/fs/cgroup
    /dev/sda1       477M   96M  352M  22% /boot
    /dev/sda3       1.9G  5.9M  1.8G   1% /home
    tmpfs            98M     0   98M   0% /run/user/0
  目的: 将分区的使用情况截取下来
  分析: 由于空格数量不一, 所以没办法直接通过cut命令直接分割, 其次, 第一行的Mounted on代表的是一列, 这里需要先将该行去除
  实现: 
      <1> df -h | grep Size
      <2> 将剩下的内容按照指定的格式输出
          printf "%s\t %s\t %s\t %s\t %s\t %s\n" $(df -h | grep Size) 
      <3> 通过cut命令切割第5列
          printf "%s\t %s\t %s\t %s\t %s\t %s\n" $(df -h | grep Size) | cut -f 5    
  ```

#### awk: 截取指定的列  
  - awk '条件一{动作一}条件二{动作二}' 文件名: (外面必须式单引号)
    ```
    条件:
      BEGIN, END, 条件表达式(> < >= <= !=)
    动作: printf $n1 "\t" $n2 或者 print $n1 "\t" $n2 ....
    注意: awk命令会自动的对每一行进行分列, 分列的依据就是连续的空格和制表符, printf或者print命令用于对这些数据进行输出
          $1.....$n 代表第n列, 每一列的值如果要用制表符分开, 制表符必须用双引号引起来, 同时整个条件动作用单引号引起来
    例如: df -h | grep -v Size | awk '{print $5}' | cut -f 1 -d "%" | awk '$1 >= 8{print $1}'

    注意: BEGIN条件会在输出前执行!!
    ```
### 字符替换命令
#### sed命令: 轻量级流编辑器, 主要用来将数据进行选取,替换,删除,新增, 对数据流进行操作, 类似于Vim   
  - sed [选项] '动作' 文件名: (!!!!!!!!!!!!!!动作必须被放入在单引号中)
    ```
    选项: 
      -n: 一般sed命令会把所有数据都输出到屏幕, 如果加入此选项则会把经过sed命令处理的行输出到屏幕
      -e: 允许对数据应用多条sed命令编辑
      -i: 用sed命令修改的结果直接修改读取数据的文件
    动作:   
      n[,m]p: 输出第n[到m]行            
      n[,m]i: 在第n[到m]行插入信息
      n[,m]a: 在第n[到m]行追加信息
      n[,m]c: 对第n[到m]行替换
      n[,m]s/旧字符/新字符/g: 对n[到m]行字符进行字符串替换, 跟vim一样
    例子:
        <1> 输入文件的第2-最后一行的内容: sed -n '2,$p' test.txt
        <2> 在第2行插入HelloWorld: sed '2i HelloWorld' test.txt(这里不用-n)
        <3> 将所有的数字替换为6: sed 's/[0-9]/66/g'
    ```
### 字符处理命令
#### sort: 对字符串进行排序    
  ```
  -r: 反向排序
  -t: 指定分隔符, 默认为制表符
  -k: 指定字段排序, 根据默认分隔符进行分割后的字段
  -n: 以数值型进行排序
  例子: 对/etc/passwd的第三个字段排序, 即uid字段1001这个 [ user2:x:1001:1001::/home/user2:/bin/bash ]
    <1> 我们需要将每一行分隔开, 分割符用冒号:, 然后选择第三个字段排序, 然后用数值排序
        cat /etc/passwd | sort -t ":" -k 3 -n
  ```
#### wc: 统计行,单词,字符数(回车也算一个字符)
  ```
  -l, -w, -m: 分别表示只统计行, 单词数, 字符数
  例子: wc /etc/passwd
  ```  
### 条件判断: [ 判断条件 ] 注意: 中括号的开始和结尾必须有空格
  - 单个文件的判断
    ```
    按文件类型判断:
      -e 文件路径: 判断文件是否存在
      -d 文件路径: 判断文件是否存在, 并是否是文件夹
      -f 文件路径: 判断文件是否存在, 并是否是普通文件
    按文件权限判断:(一般不用, 因为这个仅仅是判断是否有读写执行权限, 而没有具体判断用户,用户组,其他组成员)
      -r 文件路径: 判断文件是否存在, 并且是否具有读权限
      -w 文件路径: 判断文件是否存在, 并且是否具有写权限
      -x 文件路径: 判断文件是否存在, 并且是否具有执行权限

    例子: 判断test.java是否存在
        [ -e test.java ] && echo yes || echo no
    ```
  - 两个文件的判断
    ```
    文件1 -ef 文件2: 判断两个文件的inode号是否一致(硬链接的判断)
    例子: 
      [ test.java -ef test/aaa.java ] && echo yes || echo no
    ```
  - 两个整数之间比较
    ```
    num1 -eq num2: 判断num1和num2是否相等
    num1 -ne num2: 判断num1和num2是否不相等	
    num1 -gt num2: 判断num1是否大于num2
    num1 -lt num2: 判断num1是否小于num2
    num1 -ge num2: 判断num1是否大于等于num2
    num1 -le num2: 判断num1是否小于等于num2

    判断一个字符串是不是整数: 将这个字符串里的数字全部替换为空, 然后放入一个新的变量, 判断这个变量是否是空
        test=echo 变量 | sed 's/[0-9]//g'
        [ "$test" == "" ] 或者 [ -z $test ]
    ``` 
  - 两个字符串的判断(字符串需要放在引号中, 即使是变量)   
    ```
    -z: 判断字符串是否为空
    -n: 判断字符串是否不为空
    "字符串A" == "字符串B": 判断两个字符串是否相等
    "字符串A" != "字符串B": 判断两个字符串是否不相等
    例子:
       [ -z "$a" ] && echo yes || echo no
       [ "$a" == "$b" ] && echo yes || echo no
    ```
  - 多重判断  
    ```
    [ 判断语句1 -a 判断语句2 ]: 两个判断语句都为真则结果为真
    [ 判断语句1 -o 判断语句2 ]: 两个判断语句只要一个为真则结果为真
    [ !判断语句 ]: 对判断语句的结果进行取反
    例子: a=66, 判断a是否大于65, 小于67
      [ $a -gt 65 -a $a -lt 67 ] && echo yes || echo no
    ```
### 分支语句
  - 单分支语句
    ```
    if [ 条件判断式 ]; then
          程序
    fi

    或者

    if [ 条件判断式 ]
        then 
            程序
    fi                
    ```
  - 双分支语句  
    ```
    if [ 条件判断式 ]
        then 
            程序
        else
            程序    
    fi 
    ```
  - 多分支语句
    ```
    if [ 条件判断式 ]
        then
          程序
    elif [ 条件判断式 ]
        then
          程序
    ...            
    else 
          程序
    fi
    ```
### case语句
  ```
  case "$变量名" in
    "值一")
      程序
      ;;
    "值二")
      程序
      ;;
    *)
      程序
      ;;
  esac      
  ```  
### for循环
  ```
  for i in 1 2 3 4...
    do
      程序
    done

  或者

  for (( i=0; i<100; i=i+1 ))
    do
      echo $i
    done

  例子: 
  for i in $(ls -a | grep .txt)
    do 
      echo $i
    done
  ```     
### while循环(条件成立进入循环)
  ```
  while [ 条件判断式 ]
    do
      程序
    done 
  ```  
### until循环(条件不成立进入循环)
  ```
  until [ 条件判断式 ]
    do 
      程序
    done
  ```  

  
